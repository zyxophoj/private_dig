package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"strings"

	"privdump/readers"
	"privdump/types"
	"privdump/utils"
)

//rip.go
//
// This is useful only for ripping data out of PRIV.TRE (whose full filename must be the first and only argument)
// currently, it extracts the indices of systems and bases.
//
// (If you have the GOG version, "game.gog" is an iso containing this file (and others))

func id_from_string(prefix string, in string) string {
	out := []byte(prefix + "_" + strings.ToUpper(in))
	for i := range out {
		if !(out[i] >= 'A' && out[i] <= 'Z') && !(out[i] >= '0' && out[i] <= '9') {
			out[i] = '_'
		}
	}
	return string(out)
}
func code_string(in string) string {
	// TODO: deal with funny characters? (there don't seem to be any)
	return "\"" + in + "\""
}
func int16_from_bytes(data []byte) int {
	i, _ := readers.Read_int16(bytes.NewReader(data))
	return i
}

func make_enum[K any](from []K, prefix string, name string, extractor func(int, K) (string, int)) {
	fmt.Println("const(")
	defer fmt.Println(")")

	indent := "\t"
	for index, k := range from {
		iname, i := extractor(index, k)
		if iname != "" {
			fmt.Println(indent+id_from_string(prefix, iname), name, "=", i)
		}
	}
}

func make_enum2[K any](from map[int]K, prefix string, name string, extractor func(int, K) (string, int)) {
	fmt.Println("const(")
	defer fmt.Println(")")

	indent := "\t"
	for index, k := range from {
		iname, i := extractor(index, k)
		if iname != "" {
			fmt.Println(indent+id_from_string(prefix, iname), name, "=", i)
		}
	}
}

func main() {
	filename := os.Args[1]
	f, err := os.Open(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	
	// PRIV.TRE file format:
	// A TRE file is essentially a library of smaller files
	//
	// Bytes 0-3: number of smaller files
	// Bytes 4-7: where the non-header data starts
	// Then we have a list of file entries.  Each file entry is:
	//   Byte 0:  Unused?  Padding?
	//   Bytes 1-65:   path+filename as a null-terminated string, padded out to 65 bytes with unintelligible crap.
	//   Bytes 66-69:  Location of file data in the .TRE file
	//   Bytes 70-73:  Size of file data
	//
	// All ints described here are little-endian
	// All paths begin with "..\\..\\"; this is probably an artifact of how the file was constructed
	//
	// A big "thank you" goes out to "Darkmage", who wrote the wiki page on this:
	// https://www.wcnews.com/wcpedia/Privateer_File_Formats

	type subfile struct {
		start  int64
		length int64
	}
	subfiles := map[string]subfile{}
	{
		f.Seek(0, 0)
		nfiles, _ := readers.Read_int_le(f)
		readers.Advance(f, 4)
		for range nfiles {
			readers.Advance(f, 1)
			filename, n, _ := readers.Read_string(f)
			readers.Advance(f, 65-n)
			location, _ := readers.Read_int_le(f)
			size, _ := readers.Read_int_le(f)
			//fmt.Println("    ",filename)
			//fmt.Println("    ","Location:", location, "Size:",size)
			//fmt.Println()

			subfiles[filename] = subfile{start: int64(location), length: int64(size)}
		}
	}

	read_form_from := func(f *os.File, where int64, expected_name string) (*types.Form, error) {
		_, err = f.Seek(where, 0)
		form, err := readers.Read_form(f)
		if err != nil {
			return form, err
		}
		if form.Name != expected_name {
			return form, errors.New(fmt.Sprintf("Expected %v form; found %v", expected_name, form.Name))
		}
		return form, err
	}

	// Base types
	// This is dirty.  We are relying on the fact that the strings in the string table are in the correct order.
	// Leading "" is there because the game starts counting these at 1
	// Trailing "Special" covers any "nonstandard" base - e.g. New Detroit, Oxford, Derelict.
	// The game uses a single type ID for all of these - and therefore so will we, even though the string table
	// does have specific strings for these bases.
	base_types_form, err := read_form_from(f, subfiles["..\\..\\DATA\\OPTIONS\\PCSTRING.IFF"].start, "STRG")
	if err != nil {
		fmt.Println(err)
		return
	}
	data := bytes.NewReader(base_types_form.Get("DATA").Data)

	strings_ := []string{}
	for len(strings_) < 27 {
		str, _, err := readers.Read_string(data)
		if err != nil {
			fmt.Println(err)
			break
		}
		strings_ = append(strings_, strings.Split(str, " ")[0])
	}
	base_type := []string{""}
	base_type = append(base_type, strings_[22:27]...)
	base_type = append(base_type, "Special")

	//Quadrants and systems
	universe, err := read_form_from(f, subfiles["..\\..\\DATA\\SECTORS\\QUADRANT.IFF"].start, "UNIV")
	if err != nil {
		fmt.Println(err)
		return
	}
	quads := universe.Get_subform("QUAD")

	// Bases
	bases, err := read_form_from(f, subfiles["..\\..\\DATA\\SECTORS\\BASES.IFF"].start, "BASE")
	if err != nil {
		fmt.Println(err)
		return
	}
	// We have now read everything we need; time to write it...

	header := []string{
		"package tables",
		"",
		"// This file was generated by rip.go.  Functionally editing it is probably a bad idea; go fmt-ing it is fine.",
		"// It contains quadrant, system and info data, plus autogenerated ID constants",
		"// IDs are generated by forcing in-game names to uppercase then replacing anything not alphanumeric with \"_\",",
		"// which is mostly fine but does result in some clunktastic IDs like  \"BASE_TUCK_S\" and \"SYS_HIND_S_VARIABLE_N_\"",
		"",
		"type QUAD_ID uint8",
		"type SYS_ID uint8",
		"type BASE_ID uint8",
		"type BASE_TYPE uint8",
		"",
	}

	for _, h := range header {
		fmt.Println(h)
	}


    // quadrants...
	make_enum(quads.Subforms, "QUAD", "QUAD_ID", func(i int, f *types.Form) (string, int) {
		for _, r2 := range f.Records {
			if r2.Name == "INFO" {
				// skip 2 16-bit ints, which seem to be coords of centre of quadrant
				name, _, _ := readers.Read_string(bytes.NewReader(r2.Data[4:]))
				return name, i
			}
		}
		//error...
		return "", -1
	})
	fmt.Println()


	// systems...
	fmt.Println("//The strange order here is quadrant first, then ASCIIbetical")
	// Single array for make_enum
	systems := []*types.Form{}
	for _, sf := range quads.Subforms {
		systems = append(systems, sf.Subforms...)
	}
	make_enum(systems, "SYS", "SYS_ID", func(_ int, syst *types.Form) (string, int) {
		for _, rec := range syst.Records {
			if rec.Name != "INFO" {
				return "", -1
			}

			id := rec.Data[0]

			name, _, _ := readers.Read_string(bytes.NewReader(rec.Data[5:]))
			return name, int(id)
		}
		return "", -1
	})

	fmt.Println()

	// parents remembers which-base-is-in-which-system info (which is read from systems and used in bases)
	parents := map[uint8]string{}

	indent := "\t"
	fmt.Println("")
	fmt.Println("type Sysinfo struct{")
	fmt.Println(indent + "Name string")
	fmt.Println(indent + "Quadrant QUAD_ID")
	fmt.Println(indent + "Bases []BASE_ID")
	fmt.Println("}")
	fmt.Println("var systems = map[SYS_ID]Sysinfo{")
	for quadrant, sf := range quads.Subforms {
		for _, syst := range sf.Subforms {
			string_id := ""
			for _, r3 := range syst.Records {
				if r3.Name == "INFO" {
					indent := "\t"
					id := r3.Data[0]
					// x,y=Coords of the system
					x := int16_from_bytes(r3.Data[1:3])
					y := int16_from_bytes(r3.Data[3:5])
					name := string(r3.Data[5 : len(r3.Data)-1])
					_, _, _ = id, x, y

					string_id = id_from_string("SYS", name)
					fmt.Print(fmt.Sprintf(indent+string_id+": Sysinfo{ Name: %v, Quadrant: %v", code_string(name), quadrant))
				}
				if r3.Name == "BASE" {
					// Bases in this system
					fmt.Print(", Bases: []BASE_ID{")
					for i, b := range r3.Data {
						parents[b] = string_id
						fmt.Print(b)
						if i != len(r3.Data)-1 {
							fmt.Print(", ")
						}
					}
					fmt.Print("}")
				}
			}
			fmt.Println("},")
		}
	}
	fmt.Println("}")
	fmt.Println()


    // bases...
	make_enum(bases.Records, "BASE", "BASE_ID", func(_ int, info *types.Record) (string, int) {
		if info.Name == "INFO" {
			// Byte 0: unique Id for this base
			// Byte 1: base type.  Note that type 6(special) covers every unique type (New Detroit, Perry, Derelict etc)
			// Bytes 2-end: Base name (null-terminated string)

			id := info.Data[0]
			//base_type  := info.Data[1]
			name, _, _ := readers.Read_string(bytes.NewReader(info.Data[2:]))
			return name, int(id)
		}
		// The first record is not "INFO" type and just contains "BASEINFO"
		return "", -1
	})

	fmt.Println()

	make_enum(base_type, "BT", "BASE_TYPE", func(i int, str string) (string, int) {
		return str, i
	})

	fmt.Println()
	fmt.Println()
	fmt.Println("type Baseinfo struct{")
	fmt.Println(indent + "Name string")
	fmt.Println(indent + "Type BASE_TYPE")
	fmt.Println(indent + "System SYS_ID")
	fmt.Println("}")
	fmt.Println("var Bases = map[BASE_ID]Baseinfo{")
	for _, info := range bases.Records {
		if info.Name == "INFO" {
			sep := "\t"
			cur := 2
			name, _, _ := readers.Read_string(bytes.NewReader(info.Data[cur:]))
			fmt.Println(sep+id_from_string("BASE", name)+": "+"Baseinfo{ Name: "+code_string(name), ", Type: "+id_from_string("BT", base_type[info.Data[1]]), ", System:", parents[info.Data[0]], "},")

		} else {
			fmt.Println("// Total number of bases of each type:") // But why?  This is redundant information.
			fmt.Println("//", info.Name, info.Data)
		}
	}
	fmt.Println("}")


    // Flags...
	flags := utils.Make_flags()
	// Although it would be funny, we don't really want flags in random order
	type flag struct {
		value int
		str   string
	}
	sorted_flags := map[types.Game][]flag{}
	for g, m := range flags {
		for i := 0; len(sorted_flags[g]) < len(m); i += 1 {
			if name, ok := m[i]; ok {
				sorted_flags[g] = append(sorted_flags[g], flag{i, name})
			}
		}
	}

	fmt.Println()
	fmt.Println("// Flags...")
	fmt.Println("// These are used to deal with fixer states that are a bit too subtle to be represented in the plot chunk")
	fmt.Println("// In Privateer, that's details like temporarily rejecting a mission.")
	fmt.Println("// In RF, it's pretty much the entire plot mission state, since multiple mission chains can be active at once")
	fmt.Println("// and a simple plot string is completely incapable of dealing with that.")

	make_enum(sorted_flags[types.GT_PRIV], "FLAG_PRIV", "", func(_ int, f flag) (string, int) {
		return f.str, f.value
	})
	fmt.Println()
	make_enum(sorted_flags[types.GT_RF], "FLAG_RF", "", func(_ int, f flag) (string, int) {
		return f.str, f.value
	})
	fmt.Println()
}
